#!/usr/bin/env python

import re, os, sys
import uuid

"""
Parametros configurables.

"""

class conf:

    "Required; set with (only) positional argument."
    basespec = None
    "Required; override with -m or --max."
    max = 2
    "Default is huge; override with -M or --scope."
    scope = 32

    "Requiered; 0 to infinite to measure if father, son, grandson, etc"
    level = 0

    "Number of -r that were provided."
    nrels = 0
    "Name of each rel (indexed by rel number)."
    relnames = {}
    "Parsed pairs of each rel (rj->(x->[ys]))"
    relpairs = {}

    "Whether aliasing should be modeled (-n)."
    aliasing = True

    count = False
    counts = False
    counts_upto = None
    quiet = False
    subset = None

    "Whether to actually produce .als files (-a)."
    saveals  = False
    "Whether to also produce GraphViz files (-d)."
    savedot  = False
    "Whether to also xlate GraphViz files to PNG (-p)."
    savepng  = False

    "Output dir to save (any) resulting files to (-o)."
    outdir   = None
    
    "Callback function for every als"
    callback_function = None
    callback_file_name = ""
    
    @staticmethod
    def subdir(s):
        return os.path.join(conf.outdir, s)

    "A rare string prefix that should not appear in input."
    magicstr = '_TROLA_REL_'

    "Likely locations for a `dot' executable."
    dotbins = ('/usr/bin/dot', '/usr/local/bin/dot',
                   '/Applications/GraphViz.app/Contents/MacOS/dot')
    dotbinary = None
    
    class debug:
        dfs = False
        choices = False
        parse = False
        relpairs = False
    
    class stats:
        nproduced = 0



"""
Entrada/salida en formatos varios.

"""


from itertools import count

class render:

    @staticmethod
    def node(n):
        "Numero de nodo como string."
        return 'null' if n is None else ('N%u' % n)

    @staticmethod
    def edge(n, m):
        "(Nro de nodo, nro de nodo) como string."
        return '->'.join((render.node(n), render.node(m)))

    @staticmethod
    def nrel(j):
        "Numero de relacion (o su nombre si provisto) como string."
        return ('r%u' % j) if not j in conf.relnames else conf.relnames[j]
    
    ith = count()


def to_alloy(nrels, choices, name):
    """
    Instancia completa como string en sintaxis Alloy.
    """
    als = []
    rellabels = [('QF.%s_0 in' % render.nrel(j)) for j in range(nrels)]
    reltuples = [[] for j in range(nrels)]

    for i, choice in enumerate(choices):
        for j, rc in enumerate(choice):
            reltuples[j].append(render.edge(i, rc))

    als.append('\n-- generated by trola %s' % TROLA_VERSION)
    for j in range(nrels):
        als.append('\n+'.join([rellabels[j]] + reltuples[j]))
        if conf.basespec:
            als.append('+' + conf.relrests[j])
    als.append('-- end trola\n')

    return ''.join(('\n', '\n\n'.join(als), '\n\n'))

    
def to_graphviz(nrels, choices, name):
    """
    Instancia completa como string en sintaxis dot.
    """
    dot = ['digraph %s {' % name]
    dot.append('\tnodesep=.5; ordering=out;')
    dot.append('\tnull [ shape = invhouse ];')
    for i, choice in enumerate(choices):
        for j, rc in enumerate(choice):
            dot.append('\t' + render.edge(i, rc) + \
                       ' \t[ label = %s ];' % render.nrel(j))
    dot.append('}')
    return '\n'.join(dot) + '\n'


def save_als(nrels, choices, name):
    """
    Crear archivo .als  (o cachito de, si no hay conf.basespec).
    """
    if conf.basespec:            
        als = conf.basespec[:]
        for j in range(nrels):
            newtups = dict(conf.relpairs[j])
            for x, choice in enumerate(choices):
                newtups[x] = [choice[j]]
            expr = []
            #print newtups
            print("Debug-mfrias4 trola.py line 153, newtups.items() = ", newtups.items())
            for x, ys in newtups.items():
                expr.append('\n+'.join(map(lambda y: render.edge(x, y), ys)))
            als = als.replace(conf.magicstr + render.nrel(j),
              'QF.%s_0 in' % render.nrel(j) + '\n' + '\n+'.join(expr) + '\n')
            print("Debug-mfrias4 trola.py line 158, als = ", als)
    else:
        als = to_alloy(nrels, choices, name)
    print("Debug-mfrias4 trola.py line 161, file where als will be solved = ", os.path.join(conf.subdir('als'), name + '.als'))
    f = open(os.path.join(conf.subdir('als'), name + '.als'), 'w')
    f.write(als)
    
    #print os.path.join(conf.subdir('als'), name+'.als')
    print("Debug-mfrias4 trola.py line 164, conf.callback_function = ", conf.callback_function)
    if conf.callback_function:
        print("Debug-mfrias4 trola.py line 166, callback_file_name = ", os.path.join(conf.subdir('als'), name+'.als'))
        conf.callback_file_name = os.path.join(conf.subdir('als'), name+'.als')

def save_dot(nrels, choices, name):
    """
    Crear archivo .dot (completo y compilable con dot).
    """
    dot = to_graphviz(nrels, choices, name)
    open(os.path.join(conf.subdir('dot'), name+'.dot'), 'w').write(dot)


def make_png(name):
    """
    Compilar con dot el .dot a un archivo de imagen PNG.
    
    Esta impl apesta. Usar popen, o algo.
    """
    
    dotpath = os.path.join(conf.subdir('dot'), name+'.dot')
    pngpath = os.path.join(conf.subdir('png'), name+'.png')
    os.system('%s -Tpng -o%s %s' % (conf.dotbinary, pngpath, dotpath))


def show(nrels, choices):
    """
    Mostrar instancia completa en pantalla, y guardar (o no) segun prefs.
    """

    name = '%s' % uuid.uuid4() #render.ith.next()
    if not conf.quiet:
        print (('%7s'%name), 72*'-')
        for i, choice in enumerate(choices):
            print( '       ', '\t\t'.join((render.nrel(j) + ': ' \
                  + render.edge(i, rc) for j, rc in enumerate(choice))))
    if conf.saveals:
        save_als(nrels, choices, name)
    if conf.savedot:
        save_dot(nrels, choices, name)
    if conf.savepng:
        make_png(name)


def regexQF(relname=None):
    """
    Devolver una expresion regular que matchea las expresiones
    Alloy de la pinta "QF.xxx_0 in tupla + tupla + ... + tupla".
    """
    if relname is None:
        relname = r"(\w+)"
    return r"QF\." + relname + r"_0\s+in\s+" + \
        r"(N\d+\s*->\s*\w+)" + r"(?:\s*\+\s*(N\d+\s*->\s*\w+))*\s*[^N]"


def parseQF(string, relname=None):
    """
    Dado el texto de una spec y el nombre de una rel, parsear
    "QF.relname_0 in ..." y devolver una lista de pares int, int/None
    asi como los offsets inicial y final del match en el texto.    
    """
    pattern = re.compile(regexQF(relname))
    hit = pattern.search(string)
    assert hit, 'error: could not find rel "' + relname + '" in base spec.'
    pos, end = hit.start(), hit.end()
    pattern = re.compile(r"(N\w+\s*->\s*\w+)")
    pairs = [l.split('->') for l in pattern.findall(string[pos:end])]
    pairs = [(int(x[1:]), (int(y[1:]) if y.startswith('N') else None)) \
        for x, y in pairs]
    if conf.debug.parse:
        print( 'debug.parse:', relname)
        print( pairs)
        print( pos, end)
    return pairs, pos, end


def parseintlist(string):
    """
    Dado string de numeros enteros separados por espacio en blanco
    y/o comas, devolver lista de ints.
    """
    string = string.replace(',', ' ')
    return map(int, string.split())


"""
El algoritmo:

"""

from itertools import product


def bacatracio(scope, limit, nrels, x=0, y=1, trail=[], reach=[]):
    """
    Recorrer DFS el espacio de heaps validos y mostrar cada uno.
    """
    print("Debug-mfrias4, trola.py line 260. Entering bacatracio")
    print("Debug-mfrias4, trola.py line 261. conf.counts_upto = ", conf.counts_upto)
    print("Debug-mfrias4, trola.py line 262. conf.stats.nproduced = ", conf.stats.nproduced)
    print("Debug-mfrias4, trola.py line 263. conf.counts_upto = ", conf.counts_upto)
    print("Debug-mfrias4, trola.py line 264. conf.stats.nproduced >= conf.counts_upto = ", conf.stats.nproduced >= conf.counts_upto)
    if conf.counts_upto and conf.stats.nproduced >= conf.counts_upto:
        print("Debug-mfrias4, trola.py line 266. in bacatracio. scope = ", scope, " limit = ", limit, " nrels = ", nrels, " x = ", x, " y = ", y)
        return
    for choice in choices(scope, limit, nrels, x, y):
        print("Debug-mfrias4, trola.py line 269. in bacatracio. choice = ", choice, " trail = ", trail)
        trail.append(choice)
        reachable = reach[:] + [rc for rc in choice if rc != None]
        print("Debug-mfrias4, trola.py line 272. in bacatracio. Reachable = ", reachable)

        if conf.debug.dfs:
            print( '\ndebug.dfs', 50 * '=', choice)
            print( '  choices:', trail)
            print( '  reachable:', reachable)
        if x+1 < limit and x+1 in reachable: # suboptimo pero zafa por ahora
            print("Debug-mfrias4 trola.py line 274 locating bug")
            m = max_nonull(choice)
            newy = (m + 1 if m else y)
            print("Debug-mfrias4, trola.py line 283. Recursive call bacatracio")
            bacatracio(scope, limit, nrels, x+1, newy, trail, reachable)
        else:
            if not conf.subset or conf.stats.nproduced in conf.subset:
                show(nrels, trail)
            conf.stats.nproduced += 1
            print("Debug-mfrias4 trola.py line 288. conf.stats.nproduced = ", conf.stats.nproduced)
            print("Debug-mfrias4 trola.py line 289. conf.callback_function = ", conf.callback_function, " and conf.saveals = ", conf.saveals)
            if conf.callback_function and conf.saveals:
            #if conf.callback_function:
                print("Debug-mfrias4, trola.py line 293. conf.callback_file_name = ", conf.callback_file_name)
                conf.callback_function(conf.callback_file_name, infinite_timeout=False, curMax=limit, level=conf.level)
            #print 'file: %s' % conf.callback_file_name
        trail.pop()

        if conf.debug.dfs:
            print( 80 * '=')


def choices(scope, limit, nrels, x, yr):
    """
    Genera las alternativas legales para x bajo yr
    (el menor y nunca aun alcanzado).
    """
    print("Debug-mfrias4 trola.py line 301, entered choices. scope = ", scope, " limit = ", limit, " nrels = ", nrels)
    if conf.debug.choices:
        print( '\n***** debug.choices *****',)
        print( 'for N%u --r*--> N?|null ***** under yr == %u *****' % (x, yr))

    # idem anterior pero ademas filtrado por las cotas parseadas
    # for relation j returns the possibilities in relation j for input x, sorted in increasing order
    print("Debug-mfrias4 trola.py line 308, entered choices. Locating bug conf.relpairs = ", conf.relpairs)    
    possible = lambda j : sorted(conf.relpairs[j][x], key=lambda x: -1 * float('inf') if x is None else x)
    print("Debug-mfrias4 trola.py line 310, entered choices. Locating bug. possible = ", possible)

    if conf.debug.choices:
        for rj in range(nrels):
            print ('\tpossible\t  %-10s %s' % (render.nrel(rj),
                ', '.join(map(str, possible(rj)))))
    
    print("Debug-mfrias4 trola.py line 319, entered choices. Locating bug")
    print("Debug-mfrias4 trola.py line 320, entered choices. Test possible = ", possible(0))
    for choice in product(*[possible(rj) for rj in range(nrels)]):
        print("Debug-mfrias4, trola.py line 320, entered choices locating bug")
        if conf.debug.choices:
            print("Debug-mfrias4, trola.py line 322, entered choices locating bug")
            print( '\n\t', '%20s'%map(str, choice),)
        ymax = yr
        ok = True
        print("Debug-mfrias4, trola.py line 326, entered choices locating bug")
        for i, rc in enumerate(choice):
            if conf.aliasing:
                print("Debug-mfrias4, trola.py line 331, entered choices locating bug")
                ok = rc is None or x < rc <= ymax
                print("Debug-mfrias4, trola.py line 333, entered choices. ok = ", ok)
            else:
                print("Debug-mfrias4, trola.py line 335, entered choices locating bug")
                ok = rc is None or rc == ymax
                print("Debug-mfrias4, trola.py line 337, entered choices. ok = ", ok)
            if not ok:
                break                
            if rc == ymax:
                ymax += 1
        if ok:
            if conf.debug.choices:
                print( '\t\t', 'OK')
            yield choice
        else:
            if conf.debug.choices:
                print( '\t\t', 'KO (%u, x=%u, ymax=%u)' % (rc, x, ymax))
    print("Debug-mfrias4 trola.py line 347, exiting choices.")


def max_nonull(choice):
    """
    max(iterable) que devuelve 0 si todos son None.
    
    """
    print("Debug-mfrias4 trola.py line 357, choice = ", choice)
    non_None_choices = [i for i in choice if i is not None]
    print("Debug-mfrias4 trola.py line 359, non_None_choices = ", non_None_choices)
    return max(non_None_choices) if len(non_None_choices)>0 else 0





"""
Entry point (main, etc) e interfase usuario.

"""




import getopt, time, sys


def show_help():
    print( TROLA_LOGO)
    show_usage()
    print( """

      -r  or  --rel    <string>       add relation (multi ok, order matters)
                                    
      -m  or  --max    <number>       wire (in domain) up to this many nodes
      -M  or  --scope  <number>       map onto (image) up to this many nodes
                                      (defaults are -m %u and -M %u)
                                    
      -n  or  --noalias               enforce a single-parent-per-node rule
                                      (default is to support aliasing)

      -a  or  --als                   save subproblems in Alloy format
      -d  or  --dot                   save subproblems in GraphViz format
      -p  or  --png                   save subproblems in PNG format
                                      (implies -d, requires `dot' program)
      -s  or  --subs <numberlist>     save only a subset of subproblems
      -o  or  --outdir  <path>        specify root subdir for saved files

      -q  or  --quiet                 keep standard output to bare minimum
      -c  or  --count                 just count subproblems for given -m
                                      (implies -q)
      -C  or  --counts  <number>      count subproblems for -m 1, 2, 3 ...
                                      upto given fanout limit (implies -q)

""" % (conf.max, conf.scope))


def show_usage():
    print( 'usage: trola.py OPTIONS template.als')

def partition(infile, outdir, scope, rels, callback, aliasing, upto=None, max=None, level=0):
    print("Debug-mfrias4, trola.py line 415. Entering partition")
    print("Debug-mfrias4, trola.py line 416. callback = ", callback)
    conf.stats.nproduced = 0
    conf.quiet = True
    conf.saveals = True
    conf.outdir = outdir
    conf.relnames = rels
    conf.nrels = len(rels)
    conf.scope = int(scope)
    conf.aliasing = aliasing
    conf.level = level
    print("Debug-mfrias4, trola.py line 425. conf.outdir = ", conf.outdir, " upto = ", upto)
    print("Debug-mfrias4, trola.py line 426. conf.relnames = ", conf.relnames, " conf.nrels = ", conf.nrels, " conf.scope = ", conf.scope, " conf.aliasing = ", conf.aliasing, " conf.level = ", conf.level, " max = ", max)

    if upto != None and max == None:
        conf.counts = True
        conf.counts_upto = int(upto)
        assert max is None
    if max != None and upto == None:
        conf.max = int(max)
    nrels = conf.nrels
    specpath = infile
    limit = conf.max
    conf.callback_function = callback

    if not nrels:
        raise IOError('It would be more useful if you provided 1 or more rels.\n')

    if not os.path.isfile(specpath):
        raise IOError('Could not open file ' + specpath + '\n')

    conf.basespecpath = specpath
    print("Debug-mfrias4, trola.py line 442 specpath = ", specpath)
    conf.basespec = open(specpath, 'r').read()

    if not conf.outdir:
        specdir, specname = os.path.split(specpath)
        specdirpar, dummy = os.path.split(specdir)
        specname, specext = os.path.splitext(specname)
        conf.outdir = os.path.join(specdirpar, specname, 'm%u' % conf.max)
    if not os.path.exists(conf.outdir):
        print("Debug-mfrias4, trola.py line 456 conf.saveals = ", conf.saveals, " conf.outdir = ", conf.outdir)
        if conf.saveals:
            os.makedirs(conf.outdir)
    elif not os.path.isdir(conf.outdir):
        raise IOError('Error: ' + conf.outdir + ' exists but isnt a directory?')

    if conf.saveals and not os.path.exists(conf.subdir('als')):
        os.mkdir(conf.subdir('als'))

    print("Debug-mfrias4 trola.py line 465 before time.time()")
    starttime = time.time()
    print("Debug-mfrias4 trola.py line 467 before time.clock()")
    startclock = time.process_time()

    if conf.basespec:
        print("Debug-mfrias4 trola.py line 465. conf.basespec = ", conf.basespec)
        conf.relpairs = dict()
        for j in range(nrels):
            relname = render.nrel(j)
            rtuples, pos, end = parseQF(conf.basespec, relname)
            conf.relpairs[j] = dict()
            for x, y in rtuples:
                if x not in conf.relpairs[j]:
                    conf.relpairs[j][x] = list()
                conf.relpairs[j][x].append(y)
                print("Debug-mfrias4, trola.py line 481, j = ", j, " conf.relpairs[j][x] = ", conf.relpairs[j][x])   
            conf.basespec = conf.basespec[:pos] + '\n' \
                + conf.magicstr + relname + '\n' + conf.basespec[end-1:] # improve!
            if conf.debug.relpairs:
                print(conf.relpairs[j])
            print("Debug-mfrias4, trola.py line 486, j = ", j, " conf.relpairs[j] = ", conf.relpairs[j])   

    if conf.counts:
        print("Debug-mfrias4, trola.py line 471, conf.counts is true")
        conf.saveals=False
        conf.max = 0
        conf.stats.nproduced = 0
        while conf.stats.nproduced < conf.counts_upto and conf.max < conf.scope: # ojo, esto esta ok? depende de si conf.max incluye o no el pasado
            conf.stats.nproduced = 0
            conf.max += 1
            print("Debug-mfrias4, trola.py line 489, Before call to bacatracio. conf.stats.nproduced = ", conf.stats.nproduced, " conf.counts_upto = ", conf.counts_upto)
            bacatracio(conf.scope, conf.max, nrels)
            print("Debug-mfrias4, trola.py line 492, After call to bacatracio. conf.stats.nproduced = ", conf.stats.nproduced, " conf.counts_upto = ", conf.counts_upto)
            #print'  tried max %u, would produce %u subps.' % (conf.max, conf.stats.nproduced) # DEBUG
            #if conf.stats.nproduced < conf.counts_upto and conf.max < conf.scope:
                #print conf.max, conf.stats.nproduced
        
        # Turn off `counts' mode and go back to normal (single-run) operation
        # conf.counts_upto was set to None
        #conf.counts, conf.counts_upto = False, -sys.maxsize - 1
        conf.counts = False
        print("Debug-mfrias4, trola.py line 507, conf.counts = ", conf.counts, " conf.counts_upto = ", conf.counts_upto, "-sys.maxsize - 1", -sys.maxsize - 1)
        
        if conf.stats.nproduced > 1:
            print("Debug-mfrias4, trola.py line 500, conf.stats.nproduced = ", conf.stats.nproduced)
            conf.level += 1
            print("Debug-mfrias4, trola.py line 502, conf.stats.nproduced < conf.counts_upto = ", conf.stats.nproduced < conf.counts_upto)
            if conf.stats.nproduced < conf.counts_upto:
                print("Debug-mfrias4, trola.py line 501, conf.stats.nproduced < conf.counts_upto")
                # usamos el mayor conf.max posible (fijar todo lo restante)
                assert conf.max == conf.scope
                conf.stats.nproduced = 0
                conf.saveals = True
                print("Debug-mfrias4, trola.py line 506, about to call bacatracio with conf.saveals = true")
                bacatracio(conf.scope, conf.max, nrels)
            else:
                # me pase del upto deseado; veamos si con el valor anterior de conf.max da >1 hijos
                print("Debug-mfrias4, trola.py line 510, conf.stats.nproduced >= conf.counts_upto = ", conf.stats.nproduced >= conf.counts_upto)
                conf.stats.nproduced = 0
                bacatracio(conf.scope, conf.max - 1, nrels)
                assert conf.stats.nproduced > 0
                #print '  retried %u, produced %u subps.' % (conf.max-1, conf.stats.nproduced) # DEBUG
                if conf.stats.nproduced == 1:
                    print("Debug-mfrias4, trola.py line 529, conf.stats.nproduced = ", conf.stats.nproduced)
                    conf.stats.nproduced = 0
                    #conf.stats.nproduced = -1
                    conf.saveals = True
                    bacatracio(conf.scope, conf.max, nrels)
                else:
                    # caso normal: usamos el anterior y producimos >1 hijos
                    print("Debug-mfrias4, trola.py line 535, normal case")
                    conf.stats.nproduced = 0
                    conf.saveals = True
                    conf.max -= 1
                    bacatracio(conf.scope, conf.max, nrels)
            #conf.stats.nproduced = 0
            #bacatracio(conf.scope, conf.max - 1, nrels)
    else:
        print("Debug-mfrias4, trola.py line 514 before bacatracio")
        bacatracio(scope, limit, nrels)
    
    print("Debug-mfrias4, trola.py line 522. conf.stats.nproduced = ", conf.stats.nproduced, " conf.max = ", conf.max, " conf.level = ", conf.level)
    return (conf.stats.nproduced, conf.max, conf.level)
    
def main():
    """
    Punto de entrada.
    """
    try:
        opts, argv = getopt.getopt(sys.argv[1:],
             'hcqadpnm:M:o:r:C:s:',
            ['help', 'count', 'quiet', 'als', 'dot', 'png', 'noalias',
             'max=', 'scope=', 'outdir=', 'rel=', 'counts=', 'sub='])

        if ('--help', '') in opts or ('-h', '') in opts:
            show_help()
            return 1

        if len(argv) != 1:
            show_usage()
            return 2

        for opt, val in opts:

            if opt in ('-c', '--count'):
                conf.count = True
                conf.quiet = True
                conf.saveals = False
                conf.savedot = False
                conf.savepng = False
            elif opt in ('-C', '--counts'):
                conf.counts = True
                conf.counts_upto = int(val)
                conf.quiet = True
                conf.saveals = False
                conf.savedot = False
                conf.savepng = False
            elif opt in ('-q', '--quiet'):
                conf.quiet = True                
            elif opt in ('-a', '--als'):
                conf.saveals = True
            elif opt in ('-d', '--dot'):
                conf.savedot = True
            elif opt in ('-p', '--png'):
                conf.savedot = True
                conf.savepng = True
                dotbinsok = [p for p in conf.dotbins if os.path.isfile(p)]
                assert dotbinsok, 'please check conf.dotbins in trola.py'
                conf.dotbinary = dotbinsok[0]
            elif opt in ('-n', '--noalias'):
                conf.aliasing = False
            elif opt in ('-o', '--outdir'):
                conf.outdir = val
            elif opt in ('-r', '--rel'):
                conf.relnames[conf.nrels] = val
                conf.nrels += 1
            elif opt in ('-m', '--max'):
                conf.max = int(val)
            elif opt in ('-M', '--scope'):
                conf.scope = int(val)
            elif opt in ('-s', '--sub'):
                conf.subset = parseintlist(val)

    except(getopt.error) as msg:
        print( msg)
        print()
        show_usage()
        return 3

    scope = conf.scope
    limit = conf.max
    nrels = conf.nrels
    specpath = argv[0]

    if not nrels:
        print('It would be more useful if you provided 1 or more rels.\n')
        show_usage()
        return 2

    if not os.path.isfile(specpath):
        print('Could not open file', specpath, '\n')
        show_usage()
        return 3

    conf.basespecpath = specpath
    conf.basespec = open(specpath, 'r').read()
    
    if not conf.outdir:
        specdir, specname = os.path.split(specpath)
        specdirpar, dummy = os.path.split(specdir)
        specname, specext = os.path.splitext(specname)
        conf.outdir = os.path.join(specdirpar, specname, 'm%u' % conf.max)
    if not os.path.exists(conf.outdir):
        if conf.saveals or conf.savedot or conf.savepng:
            os.makedirs(conf.outdir)
    elif os.path.isdir(conf.outdir):
        if not conf.quiet:
            print("Warning: output dir `%s' already exists." % conf.outdir)
    else:
        print("Error: `%s' exists but isn't a directory?" % conf.outdir)
        return 4

    if conf.saveals and not os.path.exists(conf.subdir('als')):
        os.mkdir(conf.subdir('als'))
    if conf.savedot and not os.path.exists(conf.subdir('dot')):
        os.mkdir(conf.subdir('dot'))
    if conf.savepng and not os.path.exists(conf.subdir('png')):
        os.mkdir(conf.subdir('png'))

    starttime, startclock = time.time(), time.clock()

    if not conf.quiet:
        print('Scope is', scope, 'with limit %u.' % limit)
        print('%u relations: %s.' % (nrels,
              ', '.join(["`"+render.nrel(j)+"'" for j in range(nrels)])))

    if conf.basespec:
        if not conf.quiet:
            print('Using specification', conf.basespecpath, 'as template.')
        conf.relpairs = dict()
        for j in range(nrels):
            relname = render.nrel(j)
            rtuples, pos, end = parseQF(conf.basespec, relname)
            conf.relpairs[j] = dict()
            for x, y in rtuples:
                if x not in conf.relpairs[j]:
                    conf.relpairs[j][x] = list()
                conf.relpairs[j][x].append(y)
            if not conf.quiet:
                print('%s[+%ub]: parsed %u tuples.' % (relname, pos, len(rtuples)))
            conf.basespec = conf.basespec[:pos] + '\n' \
                + conf.magicstr + relname + '\n' + conf.basespec[end-1:] # improve!
            if conf.debug.relpairs:
                print(conf.relpairs[j])

    if not conf.quiet:
        print(TROLA_LOGO)

    if conf.counts:
        conf.max = 0
        conf.stats.nproduced = 0
        while conf.stats.nproduced < conf.counts_upto and conf.max < conf.scope:
            conf.stats.nproduced = 0
            conf.max += 1
            bacatracio(scope, conf.max, nrels)
            if conf.stats.nproduced < conf.counts_upto and conf.max < conf.scope:
                print(conf.max, conf.stats.nproduced)
    else:
        bacatracio(scope, limit, nrels)

    if not conf.quiet:
        print('       ', 72 * '-')
        print('\n%u subproblems   %.2f walltime   ~%.2f cpu secs' \
              % (conf.stats.nproduced,
                 time.time() - starttime,
                 time.clock() - startclock))

    if conf.count:
        print(conf.stats.nproduced)

    return 0




TROLA_VERSION = '0.3b973 (chau bug ymax + bug inf.TO + bug max)'

TROLA_LOGO = \
"""
                                       88              
       ,d                              88     
       88                              88              
     MM88MMM  8b,dPPYba,   ,adPPYba,   88  ,adPPYYba,  
       88     88P'   "Y8  a8"     "8a  88  ""     `Y8  
       88     88          8b       d8  88  ,adPPPPP88  
       88,    88          "8a,   ,a8"  88  88,    ,88  
       "Y888  88           `"YbbdP"'   88  `"8bbdP"Y8     v%s

""" % TROLA_VERSION



if __name__ == "__main__":
    sys.exit(main())
