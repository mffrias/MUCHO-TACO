#!/usr/bin/env python

import re, os


"""
Parametros configurables.

"""

class conf:

    "Required; set with (only) positional argument."
    basespec = None
    "Required; override with -m or --max."
    max = 2
    "Default is huge; override with -M or --scope."
    scope = 32

    "Number of -r that were provided."
    nrels = 0
    "Name of each rel (indexed by rel number)."
    relnames = {}
    "Parsed pairs of each rel (rj->(x->[ys]))"
    relpairs = {}

    "Whether aliasing should be modeled (-n)."
    aliasing = True

    count = False
    counts = False
    counts_upto = None
    quiet = False
    subset = None

    "Whether to actually produce .als files (-a)."
    saveals  = False
    "Whether to also produce GraphViz files (-d)."
    savedot  = False
    "Whether to also xlate GraphViz files to PNG (-p)."
    savepng  = False

    "Output dir to save (any) resulting files to (-o)."
    outdir   = None
    
    @staticmethod
    def subdir(s):
        return os.path.join(conf.outdir, s)

    "A rare string prefix that should not appear in input."
    magicstr = '_TROLA_REL_'

    "Likely locations for a `dot' executable."
    dotbins = ('/usr/bin/dot', '/usr/local/bin/dot',
                   '/Applications/GraphViz.app/Contents/MacOS/dot')
    dotbinary = None
    
    class debug:
        dfs = False
        choices = False
        parse = False
        relpairs = False
    
    class stats:
        nproduced = 0



"""
Entrada/salida en formatos varios.

"""


from itertools import count

class render:

    @staticmethod
    def node(n):
        "Numero de nodo como string."
        return 'null' if n is None else ('N%u' % n)

    @staticmethod
    def edge(n, m):
        "(Nro de nodo, nro de nodo) como string."
        return '->'.join((render.node(n), render.node(m)))

    @staticmethod
    def nrel(j):
        "Numero de relacion (o su nombre si provisto) como string."
        return ('r%u' % j) if not j in conf.relnames else conf.relnames[j]
    
    ith = count()


def to_alloy(nrels, choices, name):
    """
    Instancia completa como string en sintaxis Alloy.
    """
    als = []
    rellabels = [('QF.%s_0 in' % render.nrel(j)) for j in range(nrels)]
    reltuples = [[] for j in range(nrels)]

    for i, choice in enumerate(choices):
        for j, rc in enumerate(choice):
            reltuples[j].append(render.edge(i, rc))

    als.append('\n-- generated by trola %s' % TROLA_VERSION)
    for j in range(nrels):
        als.append('\n+'.join([rellabels[j]] + reltuples[j]))
        if conf.basespec:
            als.append('+' + conf.relrests[j])
    als.append('-- end trola\n')

    return ''.join(('\n', '\n\n'.join(als), '\n\n'))

    
def to_graphviz(nrels, choices, name):
    """
    Instancia completa como string en sintaxis dot.
    """
    dot = ['digraph %s {' % name]
    dot.append('\tnodesep=.5; ordering=out;')
    dot.append('\tnull [ shape = invhouse ];')
    for i, choice in enumerate(choices):
        for j, rc in enumerate(choice):
            dot.append('\t' + render.edge(i, rc) + \
                       ' \t[ label = %s ];' % render.nrel(j))
    dot.append('}')
    return '\n'.join(dot) + '\n'


def save_als(nrels, choices, name):
    """
    Crear archivo .als  (o cachito de, si no hay conf.basespec).
    """
    if conf.basespec:            
        als = conf.basespec[:]
        for j in range(nrels):
            newtups = dict(conf.relpairs[j])
            for x, choice in enumerate(choices):
                newtups[x] = [choice[j]]
            expr = []
            #print newtups
            for x, ys in newtups.iteritems():
                expr.append('\n+'.join(map(lambda y: render.edge(x, y), ys)))
            als = als.replace(conf.magicstr + render.nrel(j),
              'QF.%s_0 in' % render.nrel(j) + '\n' + '\n+'.join(expr) + '\n')
    else:
        als = to_alloy(nrels, choices, name)

    f = open(os.path.join(conf.subdir('als'), name+'.als'), 'w')
    f.write(als)


def save_dot(nrels, choices, name):
    """
    Crear archivo .dot (completo y compilable con dot).
    """
    dot = to_graphviz(nrels, choices, name)
    open(os.path.join(conf.subdir('dot'), name+'.dot'), 'w').write(dot)


def make_png(name):
    """
    Compilar con dot el .dot a un archivo de imagen PNG.
    
    Esta impl apesta. Usar popen, o algo.
    """
    
    dotpath = os.path.join(conf.subdir('dot'), name+'.dot')
    pngpath = os.path.join(conf.subdir('png'), name+'.png')
    os.system('%s -Tpng -o%s %s' % (conf.dotbinary, pngpath, dotpath))


def show(nrels, choices):
    """
    Mostrar instancia completa en pantalla, y guardar (o no) segun prefs.
    """

    name = 's%u' % conf.stats.nproduced #render.ith.next()
    if not conf.quiet:
        print ('%7s'%name), 72*'-'
        for i, choice in enumerate(choices):
            print '       ', '\t\t'.join((render.nrel(j) + ': ' \
                  + render.edge(i, rc) for j, rc in enumerate(choice)))
    if conf.saveals:
        save_als(nrels, choices, name)
    if conf.savedot:
        save_dot(nrels, choices, name)
    if conf.savepng:
        make_png(name)


def regexQF(relname=None):
    """
    Devolver una expresion regular que matchea las expresiones
    Alloy de la pinta "QF.xxx_0 in tupla + tupla + ... + tupla".
    """
    if relname is None:
        relname = r"(\w+)"
    return r"QF\." + relname + r"_0\s+in\s+" + \
        r"(N\d+\s*->\s*\w+)" + r"(?:\s*\+\s*(N\d+\s*->\s*\w+))*\s*[^N]"


def parseQF(string, relname=None):
    """
    Dado el texto de una spec y el nombre de una rel, parsear
    "QF.relname_0 in ..." y devolver una lista de pares int, int/None
    asi como los offsets inicial y final del match en el texto.    
    """
    pattern = re.compile(regexQF(relname))
    hit = pattern.search(string)
    assert hit, 'error: could not find rel "' + relname + '" in base spec.'
    pos, end = hit.start(), hit.end()
    pattern = re.compile(r"(N\w+\s*->\s*\w+)")
    pairs = [l.split('->') for l in pattern.findall(string[pos:end])]
    pairs = [(int(x[1:]), (int(y[1:]) if y.startswith('N') else None)) \
        for x, y in pairs]
    if conf.debug.parse:
        print 'debug.parse:', relname
        print pairs
        print pos, end
    return pairs, pos, end


def parseintlist(string):
    """
    Dado string de numeros enteros separados por espacio en blanco
    y/o comas, devolver lista de ints.
    """
    string = string.replace(',', ' ')
    return map(int, string.split())


"""
El algoritmo:

"""

from itertools import product


def bacatracio(scope, limit, nrels, x=0, y=1, trail=[], reach=[]):
    """
    Recorrer DFS el espacio de heaps validos y mostrar cada uno.
    """
    if conf.counts_upto and conf.stats.nproduced >= conf.counts_upto:
        return
        
    for choice in choices(scope, limit, nrels, x, y):

        trail.append(choice)
        reachable = reach[:] + [rc for rc in choice if rc != None]

        if conf.debug.dfs:
            print '\ndebug.dfs', 50 * '=', choice
            print '  choices:', trail
            print '  reachable:', reachable

        if x+1 < limit and x+1 in reachable: # suboptimo pero zafa por ahora
            m = max_nonull(choice)
            newy = m+1 if m else y
            bacatracio(scope, limit, nrels, x+1, newy, trail, reachable)
        else:
            if not conf.subset or conf.stats.nproduced in conf.subset:
                show(nrels, trail)
            conf.stats.nproduced += 1
                    
        trail.pop()

        if conf.debug.dfs:
            print 80 * '='


def choices(scope, limit, nrels, x, yr):
    """
    Genera las alternativas legales para x bajo yr
    (el menor y nunca aun alcanzado).
    """

    if conf.debug.choices:
        print '\n***** debug.choices *****',
        print 'for N%u --r*--> N?|null ***** under yr == %u *****' % (x, yr)

    # idem anterior pero ademas filtrado por las cotas parseadas
    possible = lambda j: sorted(conf.relpairs[j][x])

    if conf.debug.choices:
        for rj in range(nrels):
            print '\tpossible\t  %-10s %s' % (render.nrel(rj),
                ', '.join(map(str, possible(rj))))
    
    for choice in product(*[possible(rj) for rj in range(nrels)]):
        if conf.debug.choices:
            print '\n\t', '%20s'%map(str, choice),
        ymax = yr
        ok = True
        for i, rc in enumerate(choice):
            if conf.aliasing:
                ok = rc is None or x < rc <= ymax
            else:
                ok = rc is None or rc == ymax
            if not ok:
                break                
            if rc == ymax:
                ymax += 1
        if ok:
            if conf.debug.choices:
                print '\t\t', 'OK'
            yield choice
        else:
            if conf.debug.choices:
                print '\t\t', 'KO (%u, x=%u, ymax=%u)' % (rc, x, ymax)


def max_nonull(choice):
    """
    max(iterable) que devuelve 0 si todos son None.
    """

    return max(choice) if any(choice) else 0





"""
Entry point (main, etc) e interfase usuario.

"""




import getopt, time, sys


def show_help():
    print TROLA_LOGO
    show_usage()
    print """

      -r  or  --rel    <string>       add relation (multi ok, order matters)
                                    
      -m  or  --max    <number>       wire (in domain) up to this many nodes
      -M  or  --scope  <number>       map onto (image) up to this many nodes
                                      (defaults are -m %u and -M %u)
                                    
      -n  or  --noalias               enforce a single-parent-per-node rule
                                      (default is to support aliasing)

      -a  or  --als                   save subproblems in Alloy format
      -d  or  --dot                   save subproblems in GraphViz format
      -p  or  --png                   save subproblems in PNG format
                                      (implies -d, requires `dot' program)
      -s  or  --subs <numberlist>     save only a subset of subproblems
      -o  or  --outdir  <path>        specify root subdir for saved files

      -q  or  --quiet                 keep standard output to bare minimum
      -c  or  --count                 just count subproblems for given -m
                                      (implies -q)
      -C  or  --counts  <number>      count subproblems for -m 1, 2, 3 ...
                                      upto given fanout limit (implies -q)

""" % (conf.max, conf.scope)


def show_usage():
    print 'usage: trola.py OPTIONS template.als'

def main():
    """
    Punto de entrada.
    """
    try:
        opts, argv = getopt.getopt(sys.argv[1:],
             'hcqadpnm:M:o:r:C:s:',
            ['help', 'count', 'quiet', 'als', 'dot', 'png', 'noalias',
             'max=', 'scope=', 'outdir=', 'rel=', 'counts=', 'sub='])

        if ('--help', '') in opts or ('-h', '') in opts:
            show_help()
            return 1

        if len(argv) != 1:
            show_usage()
            return 2

        for opt, val in opts:

            if opt in ('-c', '--count'):
                conf.count = True
                conf.quiet = True
                conf.saveals = False
                conf.savedot = False
                conf.savepng = False
            elif opt in ('-C', '--counts'):
                conf.counts = True
                conf.counts_upto = int(val)
                conf.quiet = True
                conf.saveals = False
                conf.savedot = False
                conf.savepng = False
            elif opt in ('-q', '--quiet'):
                conf.quiet = True                
            elif opt in ('-a', '--als'):
                conf.saveals = True
            elif opt in ('-d', '--dot'):
                conf.savedot = True
            elif opt in ('-p', '--png'):
                conf.savedot = True
                conf.savepng = True
                dotbinsok = [p for p in conf.dotbins if os.path.isfile(p)]
                assert dotbinsok, 'please check conf.dotbins in trola.py'
                conf.dotbinary = dotbinsok[0]
            elif opt in ('-n', '--noalias'):
                conf.aliasing = False
            elif opt in ('-o', '--outdir'):
                conf.outdir = val
            elif opt in ('-r', '--rel'):
                conf.relnames[conf.nrels] = val
                conf.nrels += 1
            elif opt in ('-m', '--max'):
                conf.max = int(val)
            elif opt in ('-M', '--scope'):
                conf.scope = int(val)
            elif opt in ('-s', '--sub'):
                conf.subset = parseintlist(val)

    except getopt.error, msg:
        print msg
        print
        show_usage()
        return 3

    scope = conf.scope
    limit = conf.max
    nrels = conf.nrels
    specpath = argv[0]

    if not nrels:
        print 'It would be more useful if you provided 1 or more rels.\n'
        show_usage()
        return 2

    if not os.path.isfile(specpath):
        print 'Could not open file', specpath, '\n'
        show_usage()
        return 3

    conf.basespecpath = specpath
    conf.basespec = open(specpath, 'r').read()
    
    if not conf.outdir:
        specdir, specname = os.path.split(specpath)
        specdirpar, dummy = os.path.split(specdir)
        specname, specext = os.path.splitext(specname)
        conf.outdir = os.path.join(specdirpar, specname, 'm%u' % conf.max)
    if not os.path.exists(conf.outdir):
        if conf.saveals or conf.savedot or conf.savepng:
            os.makedirs(conf.outdir)
    elif os.path.isdir(conf.outdir):
        if not conf.quiet:
            print "Warning: output dir `%s' already exists." % conf.outdir
    else:
        print "Error: `%s' exists but isn't a directory?" % conf.outdir
        return 4

    if conf.saveals and not os.path.exists(conf.subdir('als')):
        os.mkdir(conf.subdir('als'))
    if conf.savedot and not os.path.exists(conf.subdir('dot')):
        os.mkdir(conf.subdir('dot'))
    if conf.savepng and not os.path.exists(conf.subdir('png')):
        os.mkdir(conf.subdir('png'))

    starttime, startclock = time.time(), time.clock()

    if not conf.quiet:
        print 'Scope is', scope, 'with limit %u.' % limit
        print '%u relations: %s.' % (nrels,
              ', '.join(["`"+render.nrel(j)+"'" for j in range(nrels)]))

    if conf.basespec:
        if not conf.quiet:
            print 'Using specification', conf.basespecpath, 'as template.'
        conf.relpairs = dict()
        for j in range(nrels):
            relname = render.nrel(j)
            rtuples, pos, end = parseQF(conf.basespec, relname)
            conf.relpairs[j] = dict()
            for x, y in rtuples:
                if x not in conf.relpairs[j]:
                    conf.relpairs[j][x] = list()
                conf.relpairs[j][x].append(y)
            if not conf.quiet:
                print '%s[+%ub]: parsed %u tuples.' % (relname, pos, len(rtuples))
            conf.basespec = conf.basespec[:pos] + '\n' \
                + conf.magicstr + relname + '\n' + conf.basespec[end-1:] # improve!
            if conf.debug.relpairs:
                print conf.relpairs[j]

    if not conf.quiet:
        print TROLA_LOGO

    if conf.counts:
        conf.max = 0
        conf.stats.nproduced = 0
        while conf.stats.nproduced < conf.counts_upto and conf.max < conf.scope:
            conf.stats.nproduced = 0
            conf.max += 1
            bacatracio(scope, conf.max, nrels)
            if conf.stats.nproduced < conf.counts_upto and conf.max < conf.scope:
                print conf.max, conf.stats.nproduced
    else:
        bacatracio(scope, limit, nrels)

    if not conf.quiet:
        print '       ', 72 * '-'
        print '\n%u subproblems   %.2f walltime   ~%.2f cpu secs' \
              % (conf.stats.nproduced,
                 time.time() - starttime,
                 time.clock() - startclock)

    if conf.count:
        print conf.stats.nproduced

    return 0




TROLA_VERSION = '0.3b971 (chau bug)'

TROLA_LOGO = \
"""
                                       88              
       ,d                              88     
       88                              88              
     MM88MMM  8b,dPPYba,   ,adPPYba,   88  ,adPPYYba,  
       88     88P'   "Y8  a8"     "8a  88  ""     `Y8  
       88     88          8b       d8  88  ,adPPPPP88  
       88,    88          "8a,   ,a8"  88  88,    ,88  
       "Y888  88           `"YbbdP"'   88  `"8bbdP"Y8     v%s

""" % TROLA_VERSION



if __name__ == "__main__":
    sys.exit(main())
